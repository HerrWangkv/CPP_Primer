面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。但OOP在程序运行时才能知道类型，而泛型编程在编译时就能获知类型。

# 1 定义模板
## 1.1 函数模板
定义一个通用的函数模板，而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本，如compare:
```cpp
//声明了一个名为T的类型参数，在该函数中表示一个类型
template <typename T> int compare(const T &v1, const T &v2) {
    if (v1 < v2) return -1;
    if (v1 < v1) return 1;
    return 0;
}
```
以关键字 ```template```开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分割的一个或多个模板参数(template parameter)的列表

- 实例化(instantiate)函数模板

    ```cout << compare(1, 0) << endl;//T为int```实参类型(int)被绑定到模板参数T的类型。

- 模板类型参数

    注意模板参数列表中不同的类型参数前必须使用关键字```class```或```typename```，逗号后也不能省略
    ```cpp
    //在模板参数列表中，typename和class没有什么不同
    template <typename T, class U> calc(const T&, const U&);
    ```
- 非类型模板参数

    一个非类型参数表示一个值而非一个类型，可以通过特定类型名来指定。在模板被实例化时，非类型参数被一个用户提供的或编译器推断的值所替代，但这些值必须是常量表达式。比如由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用：
    ```cpp
    //N和M分别表示两个数组的长度
    template <unsigned N, unsigned M> 
    int compare(const char (&p1)[N], const char (&p2)[M]) {
        return strcmp(p1, p2);
    }

    //调用
    compare("hi", "mom");
    ```
    由于编译器会在一个字符串字面常量的末尾插入一个空字符，因此编译器会实例化出如下版本：
    ```cpp
    int compare(const char (&p1)[3], const char (&p2)[4])
    ```
    也就是说编译器自动识别合适的数组长度给N和M。

- inline和constexpr的函数模板

    inline或constexpr 紧靠在返回类型之前：
    ```cpp
    template <typename T> inline T min(const T&, const T&);
    ```
- 编写类型无关的代码

    编写泛型代码的2个原则：
    1. 模板中的函数参数是const的引用，以保证函数可以用于不能拷贝的类型以及更快处理大对象。
    2. 函数体中的条件判断仅使用 ```<```比较运算

    如果还想要比较无关指针地址大小，由于[比较指向无关对象的指针会产生未定义的行为，使用less](./14_重载运算与类型转换.md#8.2-标准库定义的函数对象)，更类型无关的版本：
    ```cpp
    //T有可能是指针类型，不支持<
    template <typename T> int compare(const T &v1, const T &v2) {
        if (less<T>() (v1, v2)) return -1；
        if (less<T>() (v2, v1)) return 1;
        return 0;
    }
    ```
- 模板编译

    当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。

    一般函数和类的成员函数声明放在头文件中，而定义放在源文件中。而模板则不同，模板的头文件既包括声明和定义。

- 大多数编译错误在实例化期间报告

    编译器可能报告错误的三个阶段：
    1. 编译模板本身时：发现语法错误
    2. 编译器遇到模板使用时：检查实参数目、参数类型是否匹配
    3. 实例化时：检查是否定义 < 运算符

## 1.2 类模板
- 定义类模板

    实现一个类似vector能实现存储的类模板。注意在类外定义函数成员时，需要标明```template <typename T> ret-type class-name<T>::member-name(param-list)```

    类模板的实现见[Blob.h](Exercise/16/Blob.h)。注意模板的头文件既包括声明和定义，且在类外定义成员函数时，不仅需要在返回类型前标明```template <typename T>```，返回类型之后的模板类名(表示作用于)不仅仅是```class-name::```，而是```class-name<T>::```

- 在类模板内使用简化模板类名```class-name```，在类模板外使用类模板名```class-name<T>```

    当我们使用一个类模板类型时必须提供模板实参，例外：在类模板的作用域内可以直接使用模板名而不提供实参：
    ```cpp
    template <typename T> class BlobPtr {
    public:
        //在类模板内使用简化模板类名
        BlobPtr &operator++();//前置运算符
        BlobPtr operator++(int);//后置运算符
        /*...*/
    };
    //在类模板作用域外使用类模板名
    template <typename T> BlobPtr<T>& BlobPtr<T>::operator++() {
        //前置需要检查
        check(curr, "Increment past end of BlobPtr");
        ++curr;
        return *this;
    }
    //对于后置运算符编译器会为int形参赋值0
    template <typename T> BlobPtr<T> BlobPtr<T>::operator++(int) {
        //此处无需检查，调用前置运算符时会进行检查
        BlobPtr ret = *this;//此处又在类模板作用域内了，简化类名
        ++*this;
        return ret;
    }
    ```
- 类模板和友元

    如果一个类模板包含一个非模板友元，则该友元被授权可以访问所有模板示例。如果某类的友元是模板，该类可以授权给所有友元模板实例，也可以只授权给特定实例。
- 一对一友好关系
    ```cpp
    //前置声明
    template <typename>
    class BlobPtr;
    template <typename>
    class Blob;
    //模板函数
    template <typename T>
    bool operator==(const Blob<T> &, const Blob<T> &);

    template <typename T>
    class Blob
    {
        //每个Blob实例仅将访问权限授予用相同类型实例化的BlobPtr和相等运算符
        //<T>表示其也是模板
        friend class BlobPtr<T>;
        //注意声明和定义时都不需要在函数名后加<T>,但声明友元时需要，以表示这是一个模板
        friend bool operator==<T>(const Blob<T> &, const Blob<T> &);
    /*...*/
    };
    ```
    注意每个Blob实例仅将访问权限授予用相同类型实例化的BlobPtr和相等运算符。

    注意即使是友元，只要该友元是模板，**定义和声明**都在头文件中。

    运用实例见[BlobMain.cpp](Exercise/16/BlobMain.cpp)
- 通用和特定的模板友好关系

    五种情况：
    1. 仅用普通类B实例化的模板类A才是B的友元，此时需要提前声明模板类A
    2. 模板类A的所有实例都是普通类B的友元
    3. 模板类A的某个实例是相同类型实例化的模板类B的友元
    4. 模板类A的每个实例都是模板类B的任何实例的友元
    5. 非模板类A是模板类B的所有实例的友元
    ```cpp
    //仅Pal需要前置声明
    template <typename T> class Pal; 
    //C不是类模板
    class C {
        //用类C实例化的Pal是C的友元
        friend class Pal<C>; //需要前置声明
        //Pal2的所有实例都是C的友元，此时无需前置声明
        template <typename T> friend class Pal2;
    };
    template <typename T> class C2 {
        //C2的每个实例都将相同实例化的Pal声明为友元
        friend class Pal<T>;//需要前置声明
        //Pal2的每个实例都是C2每个实例的友元，故typename不同
        template <typename X> friend class Pal2;
        //非模板类Pal3是C2所有实例的友元
        friend class Pal3;
    }
    ```
- 令模板自己的类型参数成为友元
  
    ```cpp
    template <typename Type> class Bar {
        friend Type;//将访问权限授予用来实例化Bar的类型
    };
    ```
    Type可以是个自定义的类类型，也可以是内置类型

- 模板类型别名

    ```cpp
    typedef Blob<string> StrBlob
    ```
    typedef只允许我们为模板的**某个实例**定义类型别名。如果想要为模板类定义类型别名，需要使用using:
    ```cpp
    template<typename T> using twin = pair<T, T>;
    template<typename T> using partNo = pair<T, unsigned>;
    twin<string> authors;//pair<string, string>
    partNo<string> books;//pair<string, unsigned>
    ```

- 类模板的static成员

    ```cpp
    template <typename T> class Foo {
    public:
        static std::size_t count() { return ctr; }
    private:
        static std::size_t ctr;
    };
    //类外对静态成员进行定义
    template <typename T> size_t Foo<T>::ctr = 0;
    ```
    同一模板类的不同实例有各自的static，尽管size_t与T无关。但每一个类(即使该类是模板类)也**有且仅有一个**定义静态成员的机会。因此将静态数据成员也定义成模板。
    ```cpp
    Foo<int> fi;
    auto ct = Foo<int>::count();
    ct = fi.count();//Foo<int>::count()
    ct = Foo::count();//错误，不知道哪个实例的count
    ```

## 1.3 模板参数
typename之后紧跟的模板参数名字可以不是T，可以任取。

- 模板参数与作用域

    模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数可以隐藏外层作用于中声明的相同名字，但模板作用域内不能重用(即使用同名参数表示其他意思)模板参数名。
- 模板声明

    模板声明必须包含模板参数：
    ```cpp
    //声明但不定义
    template <typename T> int compare(const T&, const T&);
    template <typename T> class Blob;
    ```
    类似函数参数，声明中的模板参数的名字不必与定义相同：
    ```cpp
    //声明
    template <typename T> T calc(const T&, const T&);
    //定义
    template <typename type> type calc(const type& a, const T]type& b) {/*...*/}
    ```
- 使用类的类型成员

    对于下面的代码(T为typename)
    ```cpp
    T::size_type *p;
    ```
    在实例化之前，编译器不知道我们在定义一个名为p的指针(如类型为T::size_type)还是将一个(类T中)名为size_type的static数据成员与名为p的变量相乘。因此我们需要显示告诉编译器T::size_type是一个类型，需要使用typename：
    ```cpp
    //typename T::value_type表示返回类型
    template <typename T>
    typename T::value_type top(const T& c) {
        if (!c.empty())
            return c.back();
        else
            //typename T::value_type为类型
            return typename T::value_type();
    }
    ```
    但此时必须使用关键字typename，而不能使用class。

- 默认模板实参

    类似函数的默认实参，我们也可以提供默认模板实参：
    ```cpp
    //compare有一个默认模板实参less<T>和一个默认函数实参F()
    template <typename T, typename F = less<T>>
    int compare(const T& v1, const T&v2, F f = F()){
        if (f(v1, v2)) return -1;
        if (f(v2, v1)) return 1;
        return 0;
    }
    ```
    类型参数F为一个可调用对象类型，可以理解为```bool (*) (const string&, string&)```