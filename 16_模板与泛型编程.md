面向对象编程(OOP)和泛型编程都能处理在编写程序时不知道类型的情况。但OOP在程序运行时才能知道类型，而泛型编程在编译时就能获知类型。

# 1 定义模板
## 1.1 函数模板
定义一个通用的函数模板，而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本，如compare:
```cpp
//声明了一个名为T的类型参数，在该函数中表示一个类型
template <typename T> int compare(const T &v1, const T &v2) {
    if (v1 < v2) return -1;
    if (v1 < v1) return 1;
    return 0;
}
```
以关键字 ```template```开始，后跟一个模板参数列表(template parameter list)，这是一个逗号分割的一个或多个模板参数(template parameter)的列表

- 实例化(instantiate)函数模板

    ```cout << compare(1, 0) << endl;//T为int```实参类型(int)被绑定到模板参数T的类型。

- 模板类型参数

    注意模板参数列表中不同的类型参数前必须使用关键字```class```或```typename```，逗号后也不能省略
    ```cpp
    //在模板参数列表中，typename和class没有什么不同
    template <typename T, class U> calc(const T&, const U&);
    ```
- 非类型模板参数

    一个非类型参数表示一个值而非一个类型，可以通过特定类型名来指定。在模板被实例化时，非类型参数被一个用户提供的或编译器推断的值所替代，但这些值必须是常量表达式。比如由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用：
    ```cpp
    //N和M分别表示两个数组的长度
    template <unsigned N, unsigned M> 
    int compare(const char (&p1)[N], const char (&p2)[M]) {
        return strcmp(p1, p2);
    }

    //调用
    compare("hi", "mom");
    ```
    由于编译器会在一个字符串字面常量的末尾插入一个空字符，因此编译器会实例化出如下版本：
    ```cpp
    int compare(const char (&p1)[3], const char (&p2)[4])
    ```
    也就是说编译器自动识别合适的数组长度给N和M。

- inline和constexpr的函数模板

    inline或constexpr 紧靠在返回类型之前：
    ```cpp
    template <typename T> inline T min(const T&, const T&);
    ```
- 编写类型无关的代码

    编写泛型代码的2个原则：
    1. 模板中的函数参数是const的引用，以保证函数可以用于不能拷贝的类型以及更快处理大对象。
    2. 函数体中的条件判断仅使用 ```<```比较运算

    如果还想要比较无关指针地址大小，由于[比较指向无关对象的指针会产生未定义的行为，使用less](./14_重载运算与类型转换.md#8.2-标准库定义的函数对象)，更类型无关的版本：
    ```cpp
    //T有可能是指针类型，不支持<
    template <typename T> int compare(const T &v1, const T &v2) {
        if (less<T>() (v1, v2)) return -1；
        if (less<T>() (v2, v1)) return 1;
        return 0;
    }
    ```
- 模板编译

    当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。

    一般函数和类的成员函数声明放在头文件中，而定义放在源文件中。而模板则不同，模板的头文件既包括声明和定义。

- 大多数编译错误在实例化期间报告

    编译器可能报告错误的三个阶段：
    1. 编译模板本身时：发现语法错误
    2. 编译器遇到模板使用时：检查实参数目、参数类型是否匹配
    3. 实例化时：检查是否定义 < 运算符

## 1.2 类模板
- 定义类模板

    实现一个类似vector能实现存储的类模板。注意在类外定义函数成员时，需要标明```template <typename T> ret-type class-name<T>::member-name(param-list)```

    类模板的实现见[Blob.h](Exercise/16/Blob.h)。注意模板的头文件既包括声明和定义，且在类外定义成员函数时，不仅需要在返回类型前标明```template <typename T>```，返回类型之后的模板类名(表示作用于)不仅仅是```class-name::```，而是```class-name<T>::```

- 在类模板内使用简化模板类名```class-name```，在类模板外使用类模板名```class-name<T>```

    当我们使用一个类模板类型时必须提供模板实参，例外：在类模板的作用域内可以直接使用模板名而不提供实参：
    ```cpp
    template <typename T> class BlobPtr {
    public:
        //在类模板内使用简化模板类名
        BlobPtr &operator++();//前置运算符
        BlobPtr operator++(int);//后置运算符
        /*...*/
    };
    //在类模板作用域外使用类模板名
    template <typename T> BlobPtr<T>& BlobPtr<T>::operator++() {
        //前置需要检查
        check(curr, "Increment past end of BlobPtr");
        ++curr;
        return *this;
    }
    //对于后置运算符编译器会为int形参赋值0
    template <typename T> BlobPtr<T> BlobPtr<T>::operator++(int) {
        //此处无需检查，调用前置运算符时会进行检查
        BlobPtr ret = *this;//此处又在类模板作用域内了，简化类名
        ++*this;
        return ret;
    }
    ```
- 类模板和友元

    如果一个类模板包含一个非模板友元，则该友元被授权可以访问所有模板示例。如果某类的友元是模板，该类可以授权给所有友元模板实例，也可以只授权给特定实例。
- 一对一友好关系
    ```cpp
    //前置声明
    template <typename>
    class BlobPtr;
    template <typename>
    class Blob;
    //模板函数
    template <typename T>
    bool operator==(const Blob<T> &, const Blob<T> &);

    template <typename T>
    class Blob
    {
        //每个Blob实例仅将访问权限授予用相同类型实例化的BlobPtr和相等运算符
        //<T>表示其也是模板
        friend class BlobPtr<T>;
        //注意声明和定义时都不需要在函数名后加<T>,但声明友元时需要，以表示这是一个模板
        friend bool operator==<T>(const Blob<T> &, const Blob<T> &);
    /*...*/
    };
    ```
    注意每个Blob实例仅将访问权限授予用相同类型实例化的BlobPtr和相等运算符。

    注意即使是友元，只要该友元是模板，**定义和声明**都在头文件中。

    运用实例见[BlobMain.cpp](Exercise/16/BlobMain.cpp)
- 通用和特定的模板友好关系

    五种情况：
    1. 仅用普通类B实例化的模板类A才是B的友元，此时需要提前声明模板类A
    2. 模板类A的所有实例都是普通类B的友元
    3. 模板类A的某个实例是相同类型实例化的模板类B的友元
    4. 模板类A的每个实例都是模板类B的任何实例的友元
    5. 非模板类A是模板类B的所有实例的友元
    ```cpp
    //仅Pal需要前置声明
    template <typename T> class Pal; 
    //C不是类模板
    class C {
        //用类C实例化的Pal是C的友元
        friend class Pal<C>; //需要前置声明
        //Pal2的所有实例都是C的友元，此时无需前置声明
        template <typename T> friend class Pal2;
    };
    template <typename T> class C2 {
        //C2的每个实例都将相同实例化的Pal声明为友元
        friend class Pal<T>;//需要前置声明
        //Pal2的每个实例都是C2每个实例的友元，故typename不同
        template <typename X> friend class Pal2;
        //非模板类Pal3是C2所有实例的友元
        friend class Pal3;
    }
    ```
- 令模板自己的类型参数成为友元
  
    ```cpp
    template <typename Type> class Bar {
        friend Type;//将访问权限授予用来实例化Bar的类型
    };
    ```
    Type可以是个自定义的类类型，也可以是内置类型

- 模板类型别名

    ```cpp
    typedef Blob<string> StrBlob
    ```
    typedef只允许我们为模板的**某个实例**定义类型别名。如果想要为模板类定义类型别名，需要使用using:
    ```cpp
    template<typename T> using twin = pair<T, T>;
    template<typename T> using partNo = pair<T, unsigned>;
    twin<string> authors;//pair<string, string>
    partNo<string> books;//pair<string, unsigned>
    ```

- 类模板的static成员

    ```cpp
    template <typename T> class Foo {
    public:
        static std::size_t count() { return ctr; }
    private:
        static std::size_t ctr;
    };
    //类外对静态成员进行定义
    template <typename T> size_t Foo<T>::ctr = 0;
    ```
    同一模板类的不同实例有各自的static，尽管size_t与T无关。但每一个类(即使该类是模板类)也**有且仅有一个**定义静态成员的机会。因此将静态数据成员也定义成模板。
    ```cpp
    Foo<int> fi;
    auto ct = Foo<int>::count();
    ct = fi.count();//Foo<int>::count()
    ct = Foo::count();//错误，不知道哪个实例的count
    ```

## 1.3 模板参数
typename之后紧跟的模板参数名字可以不是T，可以任取。

- 模板参数与作用域

    模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数可以隐藏外层作用于中声明的相同名字，但模板作用域内不能重用(即使用同名参数表示其他意思)模板参数名。
- 模板声明

    模板声明必须包含模板参数：
    ```cpp
    //声明但不定义
    template <typename T> int compare(const T&, const T&);
    template <typename T> class Blob;
    ```
    类似函数参数，声明中的模板参数的名字不必与定义相同：
    ```cpp
    //声明
    template <typename T> T calc(const T&, const T&);
    //定义
    template <typename type> type calc(const type& a, const T]type& b) {/*...*/}
    ```
- 使用类的类型成员

    对于下面的代码(T为typename)
    ```cpp
    T::size_type *p;
    ```
    在实例化之前，编译器不知道我们在定义一个名为p的指针(如类型为T::size_type)还是将一个(类T中)名为size_type的static数据成员与名为p的变量相乘。因此我们需要显示告诉编译器T::size_type是一个类型，需要使用typename：
    ```cpp
    //typename T::value_type表示返回类型
    template <typename T>
    typename T::value_type top(const T& c) {
        if (!c.empty())
            return c.back();
        else
            //typename T::value_type为类型
            return typename T::value_type();
    }
    ```
    但此时必须使用关键字typename，而不能使用class。

- 默认模板实参

    类似函数的默认实参，我们也可以提供默认模板实参：
    ```cpp
    //compare有一个默认模板实参less<T>和一个默认函数实参F()
    template <typename T, typename F = less<T>>
    int compare(const T& v1, const T&v2, F f = F()){
        if (f(v1, v2)) return -1;
        if (f(v2, v1)) return 1;
        return 0;
    }
    bool i = compare(0, 42);//使用less，i为-1
    ```
    类型参数F为一个可调用对象类型，可以理解为```bool (*) (const string&, string&)```，```F f = F()```表示对f进行默认初始化，并将该初始化的变量作为默认实参。

- 默认模板实参与类模板

    即使一个类模板拥有默认模板实参，在使用时也需要加上尖括号(尖括号内为空时表示采用默认模板实参)：
    ```cpp
    template <class T = int> class Numbers {
    public:
        Numbers(T v = 0) : val(v) { }
    private:
        T val;
    };
    Numbers<> average_precision;//表示希望使用默认类型
    ```

## 1.4 成员模板
一个类(无论是普通类还是类模板)可以包含本身是模板的成员函数，称为**成员模板**。**成员模板不能是虚函数**。

- 普通(非模板)类的成员模板

    一个用于删除动态指针的类：[DebugDelete](Exercise/16/DebugDelete.cpp)
    
    由于DebugDelete对象会delete其给定的指针，我们可以将DebugDelete用作unique_ptr的删除器：
    ```cpp
    //给出删除器类型并提供一个这种类型的对象
    unique_ptr<int, DebugDelete> p(new int, DebugDelete());
    ```
- 类模板的成员模板

    类模板如果有成员模板，则类和成员各自有自己的独立的模板参数：
    ```cpp
    template <typename T> class Blob {
        //构造函数模板
        template <typename It> Blob(It b, It e);
    };
    ```
    与类模板的普通函数成员不同，在类外定义成员模板时，必须同时为类模板和成员模板提供模板参数列表：
    ```cpp
    template <typename T>
    template <typename It>
        Blob<T>::Blob(It b, It e): data(make_shared<vector<T>>(b, e)) { }
    ```
- 实例化与成员模板

    ```cpp
    int ia[] = {1,2,3,4,5};
    vector<long> vi = {1,2,3,4,5};
    list<const char*> w = {"Got","ya"};
    //Blob<int>::Blob(int*, int*)
    Blob<int> a1(begin(ia), end(ia));
    //Blob<int>::Blob(vector<long>::iterator, vector<long>::iterator)
    Blob<int> a2(vi.begin(), vi.end());
    //Blob<string>::Blob(list<const char*>::iterator, list<const char*>::iterator)
    Blob<string> a3(w.begin(), w.end());
    ```

## 1.5 控制实例化
一般情况下，编译器在使用模板时才会实例化代码，但在大系统中，实例化相同模板的额外开销(在多个文件中使用相同模板并提供相同模板参数)可能非常严重。新标准允许我们提前通过**显式实例化**来避免这一开销。
```cpp
extern template class Blob<string>;//extern实例化声明
template int compare(const int&, const int&);//非extern实例化声明，也称实例化定义
```
当编译器遇到extern模板声明时，表示承诺在程序其他位置(其他文件)有该实例化的一个非extern声明，并不会在本文件中生成实例化代码。对于一个给定的实例化版本，可能有多个extern声明，但仅有一个非extern声明。但由于编译器在使用一个模板时自动对其实例化，因此**extern声明必须在任何使用此实例化版本的代码之前。
```cpp
//这些模板类型必须在程序其他位置进行实例化
extern tenplate class Blob<string>;
extern template int compare(const int&, const int&);

Blob<string> sa1, sa2;//Blob<string>的代码不会在此时实例化，但变量sa1,sa2可以借助程序别处的实例化代码生成
//Blob<int>的接受initializer_list的构造函数在本文件中实例化
Blob<int> a1 = {1,2,3,4,5};
Blob<int> a2(a1);//拷贝构造函数在本文件中被实例化。
int i = compare(a1[0], a2[0]);//别处实例化
```

- 非extern声明会实例化所有成员
    
    正如上方代码，使用到类模板中的某个函数时并不会直接实例化整个类模板。但是一个类模板的实例化定义(非extern声明)会实例化该模板的所有成员。

# 2 模板实参推断
对于函数模板，编译器利用调用中的函数实参来确定其模板参数。此过程被称作**模板实参推断**
## 2.1 类型转换与模板类型参数
模板所允许的形参实参转换：
1. 顶层const(对象本身const)无论在形参中还是在实参中，都会被忽略：const对象可以被同类型非const对象初始化，const对象可以用于初始化同类型非const对象。
2. const转换：可将一个非const对象的引用(或指针)传递给一个const的引用(或指针)
3. 数组或函数指针转换：如果函数形参不是引用类型，则一个数组/函数实参可以转换为指向其首元素/该函数类型的指针。
   
算术转换(float转int等)、派生类向基类的转换以及用户定义的转换(如非explicit的仅接受一个参数的构造函数等)都不能应用与函数模板。

```cpp
template <typename T> T fobj(T, T);
template <typename T> T fref(const T&, const T&);

string s1("a value");
const string s2("another value");
fobj(s1, s2);//s2的顶层const被忽略
fref(s1, s2);//对s1进行const转换

int a[10], b[42];
fobj(a, b);//调用f(int*, int*)
fref(a, b);//错误
```

- 使用相同模板参数类型的函数形参

    如果模板中形参类型相同，实参类型也必须相同：
    ```cpp
    long lng;
    compare(lng, 1024);//错误，不能实例化compare(long, int)
    ```
    如果希望允许对函数实参进行类型转换，必须将形参类型定义成不同类型：
    ```cpp
    template <typename A, typename B>
    int flexibleCompare(const A& v1, const B& v2) {
        if (v1 < v2) return -1;
        if (v2 < v1) return 1;
        return 0;
    }
    ```

- 正常类型转换应用与普通函数实参

    如果函数参数类型不是模板参数，则对实参进行正常的类型转换

## 2.2 函数模板显式实参
编译器有时无法推断出模板实参的类型，故有时候希望允许用户控制模板实例化。

- 指定显式模板实参

    ```cpp
    template <typename T1, typename T2, typename T3>
    T1 sum(T2, T3);

    int i;
    long lng;
    long val3 = sum<long>(i,lng);//long sum(int, long)
    ```
    在本例中没有任何函数实参的类型可用来推断T1的类型，故每次调用sum时都必须为T1提供一个显式模板实参，如尖括号里的long。

    显式模板实参按从左到右的顺序与对应的模板参数匹配。上例中我们省略了T2和T3显式模板实参的指定，是因为它们在模板参数列表```<typename T1, typename T2, typename T3>```中位于T1后面，且可以通过函数参数推断出来。但下例中则不可省略：
    ```cpp
    template <typename T1, typename T2, typename T3>
    T3 alternative_sum(T2, T1);

    //此时我们必须为所有三个形参指定实参
    long val2 = alternative_sum<long, int, long>(i, lng)
    ```

- 正常类型转换应用于显式指定的实参

    函数模板不允许类型转换，但如果我们显式指定模板实参，也可以进行正常的类型转换。因为已经实例化的函数模板相当于普通非模板函数了。
    ```cpp
    template <typename T>
    int compare(const T&, const T&);

    long lng;
    compare(lng, 1024);//错误，不能实例化compare(long, int)
    compare<long>(lng, 1024);//正确，实例化compare(long, long)
    compare<int>(lng, 1024);//正确，实例化compare(int, int)
    ```

## 2.3 尾置返回类型与类型转换
有时我们可以确定函数模板的输出类型与输入类型之间的关系，此时再要求显式指定模板实参会给用户增添额外负担。故可以使用尾置返回类型：
```cpp
//注意decltype(*beg)相当于It&
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg) {
    return *beg;
}
```
- 进行类型转换的标准库模板类

    头文件```type_traits```中定义了**类型转换**模板：

    ![表16.1](Images/16_1.png)

    以remove_reference为例。该模板的每个实例都有一个public的```type```成员(其实是类型别名)，表示去除引用之后的类型。remove_reference<int&>::type即为int。

    如果fcn函数想返回一个元素的值，而不是引用，则：
    ```cpp
    template <typename It>
    //必须在返回类型的声明中使用typename告诉编译器，type表示一个类型，而不是一个数据成员
    auto fcn2(It beg, It end) -> typename remove_reference<decltype(*beg)>::type {
        return *beg;
    }
    ```
## 2.4 函数指针和实参推断
当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参：
```cpp
template <typename T> int compare(const T&, const T&);
int (*pf1) (const int&, const int&) = compare;//T实例化为int
```
如果函数的形参是函数指针类型，且无法从函数指针类型确定模板实参，则会产生错误。这种情况尤其常出现在重载函数中：
```cpp
//重载func，使其形参类型为函数指针
void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));

func(compare);//错误，无法确定compare的哪个实例
func(compare<int>);//传递compare(const int&, const int&)
```

## 2.5 模板实参推断和引用
- 从左值引用函数参数推断类型

    但一个函数参数是模板类型参数的一个非const的左值引用(如T&)时，只能传递给他一个左值。且如果实参是const(底层const，不能忽略)的，则T被推断为const类型。而当形参类型是```const T&```时，实参可以是const/非const：
    ```cpp
    template <typename T> void f1(T&);//实参必须是左值
    template <typename T> void f2(const T&);//实参可以是右值

    int i;
    const int ci;
    f1(i);//T表示int
    f1(ci);//T表示const int
    f1(5);//错误，实参不是左值

    f2(i);//T表示int
    f2(ci);//ci为const int, 但T表示int
    f2(5);//正确，T是int
    ```
- 从右值引用函数参数推断类型

    实参必须为右值
    ```cpp
    template <typename T> void f3(T&&);
    f3(42);//实参是一个int类型的右值，T是int
    ```

- 引用折叠和右值引用参数

    两个例外规则：
    1. 当我们将一个左值(如i)传递给函数的右值引用参数，且此右值引用指向模板类型参数(如T&&)时，编译器推断模板类型参数(T)为实参的左值引用类型，即当我们调用```f3(i)```时，T被推断为```int&```
    2. 我们[无法直接创建一个引用的引用](02_变量和基本类型.md#3.1-引用)，但如果我们(通过类型别名或模板类型参数)**间接**创建一个引用的引用，则这些引用形成了**折叠**：
        - ```X& &```、```X& &&```、```X&& &```会折叠成左值引用```X&```
        - ```X&& &&```折叠成右值引用```X&&```
    ```cpp
    template <typename T> void f3(T&&);
    int i;
    const int ci;
    f3(i);//实参是一个左值，模板类型T是int&, int& &&折叠成左值引用int &
    f3(ci);//实参是一个左值，模板类型T是const int&, const int& &&折叠成左值引用const int &
    ```
- 编写接受右值引用参数的模板函数

    ```cpp
    template <typename T> void f3(T&& val) {
        T t = val;
        t = fcn(t);
        if (val == t) {/*...*/}//若T是引用类型，则一直为true
    }
    ```
    1. 对一个右值调用f3如```f3(42)```：T为int。此时局部变量t的类型为int，通过拷贝参数val的值被初始化。因此改变t的值时val保持不变。
    2. 对一个左值调用f3如```f3(i)```: T为int&。因此将左值引用t绑定到val变量(i)上。当我们对t赋值时，同时也改变了val的值。条件语句一致为true

    但此时由于多种可能存在的情况，代码的编写就异常困难。因此使用右值引用的函数模板通常使用如下方式重载：
    ```cpp
    template <typename T> void f(T&&);//绑定到非const右值
    template <typename T> void f(const T&);//左值和const右值
    ```
    
    实际中，右值引用常用于实参转发即模板重载。

## 2.6 理解std::move