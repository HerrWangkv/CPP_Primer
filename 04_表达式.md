# 1 基础
## 1.1 基本概念
- 左值和右值(部分见[右值引用](./13_拷贝控制.md#6.1-右值引用))

  C语言中指赋值语句的左侧/右侧。C++中当一个对象被用作右值时，用的是对象的内容；而当对象被当作左值时，用的是对象的身份(在内存中的位置)。左值可以替代右值(输入地址来表示内容)，但是右值不能替代左值。
  1. 赋值运算符需要一个(非常量)左值作为其左侧运算对象
  2. 取地址符 & 作用于一个左值运算对象，返回一个指向该运算对象的指针。该指针是一个右值
  3. 解引用运算符 * ,下标运算符[]的求值结果都是左值  
  4. 内置类型和迭代器的递增递减运算符(**前置版本**)作用于左值运算对象，所得结果也是左值。 
   ```cpp
   int i = 42
   int a[10];
   // a[0]为左值
   a[0] = i;
   // *p为左值， a[0]为左值， &a[0]为右值
   int *p = &a[0];
   ```
   如果表达式的求值结果是左值，decltype作用于该表达式(不是变量)得到一个**引用类型**。所以如果 p 是一个整型指针，decltype(*p) 的结果是int &；而对于整型i, 因为取地址符&生成右值, decltype(&i)的结果是int *, 一个整型指针。详见[decltype](./decltype.md)
## 1.2 优先级与结合律
- 优先级：3 + 4 * 5 = 23，而不是7 * 5 = 35
- (左)结合律(如果运算符的优先级相同，从左向右顺序运算)：20 - 15 -3 = 2，而不是20-（15 - 3） = 8
  
  少数运算符才满足右结合律(从右向左)，如[赋值运算符](#4-赋值运算符)、[sizeof](#9-sizeof运算符)
## 1.3 求值顺序
很多运算符，如 << 没有明确规定何时及如何对运算对象求值：
```cpp
int i = 0;
cout << i << " " << ++i << endl;
```
编译器可能先求 ++i 的值再求 i 的值，也可能先求 i 的值再求 ++i。有4种运算符明确规定了运算对象的求值顺序：
1. 逻辑与```&&```：先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值
2. 逻辑或```||```：先求左侧运算对象的值，只有当左侧运算对象的值为假时才继续求右侧运算对象的值
3. 条件运算符```?:```, 见[条件运算符](#7-条件运算符-cond--expr1--expr2)
4. 逗号```,```, 见[逗号运算符](#10-逗号运算符)

- 求值顺序、优先级、结合律
  
  f() + g() * h() + j()
  - 优先级：g()的返回值和h()的返回值相乘
  - 结合律：f()的返回值先与g()和h()的乘积相加，所得结果再与j()的返回值相加
  - 求值顺序：对于这些函数的调用顺序没有明确规定
  - 如果某几个函数改变同一对象。则它是一个错误的表达式
- 处理复合表达式的方法
  - 不确定时用括号来强制让表达式组合关系符合程序逻辑
  - 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。**除非**改变运算对象的子表达式本身(++iter)就是另一个子表达式(*p)的运算对象，如 *++iter

# 2 算术运算符
```cpp
bool b = true;
bool b2 = -b; // b2是true! (-1转化成bool类型为true)
```
- 环绕 wrapped around: 两个符号位本来都是0的带符号数，由于相加溢出符号位被改成了1，输出一个负值的现象称为**环绕**。
- 取余：如果m和n均为整数，且均非0，m%n与m符号相同，而除法结果会偏向0
  ```cpp
  21 / -5 //结果为-4
  21 % -5 //结果为1
  ```
# 3 逻辑和关系运算符
1. 逻辑与'&&'：先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值
2. 逻辑或'||'：先求左侧运算对象的值，只有当左侧运算对象的值为假时才继续求右侧运算对象的值
3. 逻辑非'！'
   
# 4 赋值运算符
赋值初始化的左侧运算对象必须是一个可修改的左值，结果的类型就是左侧运算对象的类型。注意初始化并非赋值
```cpp
int i = 0; //初始化而非赋值
const int ci = i; //初始化而非赋值
```
- 赋值运算满足右结合律
  1. 左侧对象可由右侧对象类型转换
    ```cpp
    int i;
    double j;
    i = j = 3.14;
    ```
    j被赋值3.14，右侧赋值表达式 j = 3.14 的结果也等于3.14。而i是整型，故i = 3

  2. 左侧对象不可由右侧对象类型转换
    ```cpp
    int ival, *pval;
    ival = pval = 0; // 报错，右侧赋值表达式尽管是万能的0，但是是指针类型，不能赋值给整型
    ```
- 复合赋值运算符
  - 算术运算符
    +=， -=， *=， /=， &=
  - [位运算符](#8-位运算符二进制)
    <<=, >>=, &=, ^=, |=

# 5 递增和递减运算符
- 前置版本 ++i：先加后输出。作用于左值，将对象本身作为左值返回
- 后置版本 i++：先输出后加。作用于左值，将对象原始值的副本作为右值返回

除非必须，否则不用递增递减运算符的后置版本

- 提防在复合表达式中错用这两个运算符
  ```cpp
  while (beg != s.end() && !isspace(*beg))
    *beg = toupper(*beg++); //错误：该赋值语句未定义
  ```
  赋值语句左右侧运算对象都用到了beg，并且右侧运算对象还改变了beg的值。也就是说：不知道先递增beg还是先对beg进行赋值。

# 6 成员访问运算符
ptr->mem等价于(*ptr).mem

箭头运算符的结果是一个左值(因为解引用符```*```返回左值)。点运算符仅当成员所属对象为左值时，结果才是左值，反之是右值。
# 7 条件运算符 cond ? expr1 : expr2
求值顺序是先计算cond的值，条件为真则对expr1求值，否则对expr2求值。

当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算结果才是左值，否则结果是右值。
- 嵌套条件运算符
  ```cpp
  finalgrade = (grade > 90)   ? "high pass"
                 : (grade < 60) ? "fail"
                                : "pass";
  ```
- 条件运算符的优先级非常低，常需要在它两端加上括号
  
# 8 位运算符（二进制）
- 移位运算符(与标准IO库中定义的<<和>>是重载关系)
  1. 左移： ```expr1 << expr2``` 
  2. 右移： ```expr1 >> expr2```

  注：expr2不能为负，且值必须小于结果位数
- 位求反运算符 ```~expr```
  
  char类型首先提升成int类型，提升时运算对象原来位保持不变，高位添加0，再按位取反。
- 位与(&)，位或(|)，位异或(^)
- 使用位运算符
  ```cpp
  #include <bitset>
  //用来表示30人是否通过。unsigned long至少32位
  unsigned long quiz1 = 0;
  //第27(从0开始)位同学通过
  quiz1 |= 1UL << 27;//1UL表示仅0位为1,其他为0的unsigned long
  // 第27(从0开始)位同学没通过
  quiz1 &= ~(1UL << 27);
  cout << bitset<sizeof(unsigned long) * 8>(quiz);
  //查看学生27是否通过
  bool status = quiz1 & (1UL << 27);
  ```
  注：0位在最右边。

- 移位运算符(也就是说输入输出符号)的优先级比算术运算符优先级低，但比关系运算符、赋值运算符和条件运算符优先级高：
  ```cpp
  cout << 42 + 10;
  cout << (10 < 42);
  cout << (a > b ? 0 : 1);
  ```

# 9 sizeof运算符
返回一条表达式或一个类型名字所占的**字节byte数**(1字节相当于8bit)，类型为size_t。共两种形式:
```cpp
sizeof (type) // 返回某一类型所占的字节数
sizeof expr // 返回某表达式结果类型的大小，而不计算其实际结果
//Sales_data为一类名
Sales_data data, *p;
sizeof (Sales_data);
sizeof p;//指针所占空间大小
sizeof *p;//p所指类型的空间大小
sizeof data.mem;//某成员对应类型的大小
sizeof Sales_data::mem;//同上句
```
- sizeof为右结合律，且与 ```*``` 运算符优先级相同，故 ```sizeof *p``` 相当于 ```sizeof (*p)```
- 对char类型(表达式)执行sizeof，结果为1
- 对引用类型执行sizeof运算得到被引用对象所占空间大小
- 对指针执行sizeof得到指针本身所占空间大小
- 对解引用指针执行sizeof得到指针指向对象所占空间大小，指针不需要有效
- 对数组执行sizeof得到整个数组所占空间大小，等价于对所有元素各执行一次sizeof，再求和。也就是说，sizeof不会把数组转换成指针
- 对string对象或vector对象执行sizeof得到该类型固定部分的大小(编译器定义，与元素类型有关，但与元素个数无关)
  
# 10 逗号运算符
首先对左侧的表达式求值。然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，最终求值结果也是左值。

逗号运算符常用于for循环中：
```cpp
for (...; ...; ++i, --j) {
  ...
}
```
# 11 类型转换
隐式转换
1. 大多数表达式中，比int类型小的整型值首先提升为较大的整数类型,如[char按位取反](#8-位运算符二进制)
2. 在条件中，非布尔值转换成布尔类型
3. 初始化过程中，初始值转化成变量类型
4. 赋值语句中，右侧运算对象转换成左侧运算对象的类型
5. 算术运算或关系运算有多种类型时
6. 函数调用中，见[实参类型转换](./06_函数.md#61-实参类型转换)
## 11.1 算术转换(把一种算术类型转换成另外一种算术类型)
1. 整数转换成浮点类型
2. 整型提升：小整数类型转换成大整数类型
3. 无符号数与带符号数相加且无符号数类型大于带符号数时，带符号数会转换成无符号数，容易导致[错误](./02_变量和基本类型.md#12-类型转换)
4. 无符号数与带符号数相加且带符号数类型大于无符号数时，结果依赖于机器
## 11.2 其他隐式类型转换
1. 数组转换成指针

  例外：
  - 数组作为decltype关键字的参数
  - 作为取地址符的对象
  - 作为sizeof的对象，
  - 作为typeid对象
2. 指针的转换
  - 0 或 nullptr能转换成任意指针类型
  - 指向任意非常量的指针能转换成 void*
  - 指向任意对象的指针能转换成 const void*
3. 转换成布尔类型
4. 转换成常量(指向非常量的指针，与非常量绑定的引用都可以指向/绑定常量)
5. 类类型定义的转换，如istream转换成bool以实现 while(cin >> s)

**编译器只会自动执行一步类型转换**

## 11.3 显示转换
通用形式：
```cpp
cast-name<type>(expression)
```
cast-name指：
- static_cast:任何不包含底层const的类型转换
- const_cast:只能改变运算对象(必须是指针或引用，普通对象不行)的底层const，常用于[函数重载](./06_函数.md#4-函数重载)
  ```cpp
  int x = 42;
    const int *i = &x;
    int *j = const_cast<int*>(i);
    cout << *j << endl; // 输出42
    ++(*j);
    cout << *j; // 输出43
    ```
- reinterpret_cast:危险，应尽量避免使用

旧式强制转换功能也很危险。
```cpp
type (expr);
(type) expr;
```